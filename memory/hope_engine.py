"""
MediaAgentIQ — HOPE Engine (v3.3.0)

Standing-instruction layer: store a rule once, evaluate it on every agent
result, fire Slack alerts autonomously.

File layout per agent:
  memory/agents/{slug}/
    HOPE.md      ← standing rules (this engine's concern)
    AGENTS.md    ← agent relationships
    MEMORY.md    ← recent task summaries
    SOUL.md      ← agent personality
    TOOLS.md     ← available tools
    IDENTITY.md  ← agent metadata
    logs/        ← daily log files
"""

from __future__ import annotations

import logging
import re
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any, Dict, List, Optional

if TYPE_CHECKING:
    from settings import Settings

logger = logging.getLogger(__name__)

# ─── HopeRule dataclass ───────────────────────────────────────────────────────

@dataclass
class HopeRule:
    rule_id: str           # "hope_001"
    agent_slug: str        # "archive_agent"
    condition: str         # natural-language trigger condition
    schedule: str          # "IMMEDIATE" | "DAILY 08:00 IST" | "WEEKLY MON 08:00 IST"
    action: str            # what to do when matched
    priority: str          # "CRITICAL" | "HIGH" | "NORMAL" | "LOW"
    status: str            # "ACTIVE" | "INACTIVE"
    created_at: str        # ISO timestamp
    trigger_count: int = 0
    last_triggered: str = "Never"


# ─── Companion file templates ─────────────────────────────────────────────────

def _agents_md(slug: str) -> str:
    return f"""# {slug} — Agent Relationships
_Auto-generated by HOPE Engine_

**Known Sibling Agents**: (populate as inter-agent events are logged)
**Upstream Agents**: —
**Downstream Agents**: —
"""

def _memory_md(slug: str) -> str:
    return f"""# {slug} — Task Memory
_Auto-generated by HOPE Engine_
_Recent task summaries are appended here by AgentMemoryLayer._
"""

def _soul_md(slug: str) -> str:
    return f"""# {slug} — Agent Soul
_Core personality and priorities_

**Primary Goal**: Process media tasks accurately and efficiently.
**Risk Tolerance**: Low — always flag uncertainty.
**Communication Style**: Concise, structured, data-driven.
"""

def _tools_md(slug: str) -> str:
    return f"""# {slug} — Available Tools
_Auto-generated by HOPE Engine_

**Core**: process(), validate_input(), get_info(), get_status()
**Memory**: get_memory_context_prompt(), _save_to_memory()
**HOPE**: add_hope_rule(), cancel_hope_rule(), list_hope_rules()
"""

def _identity_md(slug: str) -> str:
    return f"""# {slug} — Agent Identity
_Auto-generated by HOPE Engine_

**Slug**: {slug}
**Platform**: MediaAgentIQ v3.3.0
**HOPE Engine**: Active
**Created**: {datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")} UTC
"""

def _hope_md_header(slug: str) -> str:
    return f"""# {slug} — HOPE Rules
_Last updated: {datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")} | Active rules: 0 | Total fired: 0_

"""


# ─── HopeEngine ───────────────────────────────────────────────────────────────

class HopeEngine:
    """
    Evaluates standing HOPE rules on every agent result and fires
    Slack alerts autonomously.

    Non-fatal: any I/O or parse error is logged and swallowed so that
    agents continue processing regardless.
    """

    # Rolling window for rate-limiting: timestamps of recent alert fires
    _alert_history: deque  # class-level shared; keyed per instance below

    def __init__(self, agent_slug: str, settings: "Settings") -> None:
        self._slug = agent_slug
        self._settings = settings

        # Resolve agent subdir
        mem_root = Path(settings.MEMORY_DIR)
        self._agent_dir: Path = mem_root / "agents" / agent_slug
        self._hope_file: Path = self._agent_dir / "HOPE.md"

        # Per-instance rate-limit window
        self._alert_window: deque = deque()

    # ── Lifecycle ─────────────────────────────────────────────────────────────

    def load(self) -> None:
        """Create agent subdir + all companion files if they don't exist. Never raises."""
        try:
            self._agent_dir.mkdir(parents=True, exist_ok=True)
            (self._agent_dir / "logs").mkdir(exist_ok=True)

            if not self._hope_file.exists():
                self._hope_file.write_text(_hope_md_header(self._slug), encoding="utf-8")
                logger.debug(f"HOPE: Created {self._hope_file}")

            for fname, fn in [
                ("AGENTS.md",   _agents_md),
                ("MEMORY.md",   _memory_md),
                ("SOUL.md",     _soul_md),
                ("TOOLS.md",    _tools_md),
                ("IDENTITY.md", _identity_md),
            ]:
                fpath = self._agent_dir / fname
                if not fpath.exists():
                    fpath.write_text(fn(self._slug), encoding="utf-8")
        except Exception as e:
            logger.warning(f"HOPE.load() failed for {self._slug} (non-fatal): {e}")

    # ── Rule management ───────────────────────────────────────────────────────

    def add_rule(
        self,
        condition: str,
        schedule: str,
        action: str,
        priority: str = "NORMAL",
    ) -> HopeRule:
        """Parse + append a new ACTIVE rule to HOPE.md. Returns the new rule."""
        try:
            rules = self.list_rules()
            # Generate next rule_id
            existing_ids = [r.rule_id for r in rules]
            n = len(existing_ids) + 1
            while True:
                rid = f"hope_{n:03d}"
                if rid not in existing_ids:
                    break
                n += 1

            rule = HopeRule(
                rule_id=rid,
                agent_slug=self._slug,
                condition=condition,
                schedule=schedule.upper(),
                action=action,
                priority=priority.upper(),
                status="ACTIVE",
                created_at=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S"),
                trigger_count=0,
                last_triggered="Never",
            )
            rules.append(rule)
            self._rewrite_hope_md(rules)
            logger.info(f"HOPE: Added rule {rid} for {self._slug}")
            return rule
        except Exception as e:
            logger.warning(f"HOPE.add_rule() failed (non-fatal): {e}")
            # Return a stub so callers don't crash
            return HopeRule(
                rule_id="hope_err",
                agent_slug=self._slug,
                condition=condition,
                schedule=schedule,
                action=action,
                priority=priority,
                status="INACTIVE",
                created_at=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S"),
            )

    def cancel_rule(self, rule_id: str) -> None:
        """Set a rule's status to INACTIVE. Never raises."""
        try:
            rules = self.list_rules()
            for r in rules:
                if r.rule_id == rule_id:
                    r.status = "INACTIVE"
            self._rewrite_hope_md(rules)
            logger.info(f"HOPE: Cancelled rule {rule_id} for {self._slug}")
        except Exception as e:
            logger.warning(f"HOPE.cancel_rule() failed (non-fatal): {e}")

    def list_rules(self) -> List[HopeRule]:
        """Parse all rules from HOPE.md. Returns empty list on error."""
        try:
            if not self._hope_file.exists():
                return []
            content = self._hope_file.read_text(encoding="utf-8")
            return self._parse_rules(content)
        except Exception as e:
            logger.warning(f"HOPE.list_rules() failed (non-fatal): {e}")
            return []

    # ── Evaluation ────────────────────────────────────────────────────────────

    def evaluate(self, result: Dict[str, Any]) -> List[HopeRule]:
        """
        Check each ACTIVE IMMEDIATE rule against the agent result.
        Returns list of matched rules.
        """
        matched: List[HopeRule] = []
        try:
            rules = self.list_rules()
            for rule in rules:
                if rule.status != "ACTIVE":
                    continue
                if not rule.schedule.startswith("IMMEDIATE"):
                    continue
                if self._matches_condition(rule.condition, result):
                    matched.append(rule)
        except Exception as e:
            logger.debug(f"HOPE.evaluate() failed (non-fatal): {e}")
        return matched

    def fire_action(self, rule: HopeRule, result: Dict[str, Any], notifier) -> None:
        """
        Increment trigger_count, update last_triggered, optionally send
        notification via notifier. Never raises.
        """
        try:
            # Mute / rate-limit checks
            if self._is_muted(rule.priority):
                logger.debug(f"HOPE: Rule {rule.rule_id} suppressed — mute hours")
                return
            if rule.priority not in ("CRITICAL",) and self._rate_limited():
                logger.debug(f"HOPE: Rule {rule.rule_id} suppressed — rate limit")
                return

            # Update rule state
            rule.trigger_count += 1
            rule.last_triggered = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")

            # Persist updated counts
            rules = self.list_rules()
            for r in rules:
                if r.rule_id == rule.rule_id:
                    r.trigger_count = rule.trigger_count
                    r.last_triggered = rule.last_triggered
            self._rewrite_hope_md(rules)

            # Record in alert window for rate limiting
            self._alert_window.append(datetime.now(timezone.utc))

            # Send notification
            if notifier:
                try:
                    from gateway.formatter import format_hope_alert
                    payload = format_hope_alert(rule, result, rule.priority)
                    # Determine channel from UserProfile
                    channel = self._resolve_channel(rule.priority)
                    notifier.send(channel=channel, payload=payload)
                except Exception as ne:
                    logger.debug(f"HOPE: Notifier send failed (non-fatal): {ne}")

            logger.info(
                f"HOPE: Fired rule {rule.rule_id} for {self._slug} "
                f"(count={rule.trigger_count}, priority={rule.priority})"
            )
        except Exception as e:
            logger.warning(f"HOPE.fire_action() failed (non-fatal): {e}")

    # ── Daily digest ──────────────────────────────────────────────────────────

    def get_daily_digest_rules(self) -> List[HopeRule]:
        """Return ACTIVE rules with DAILY schedule."""
        return [
            r for r in self.list_rules()
            if r.status == "ACTIVE" and r.schedule.startswith("DAILY")
        ]

    def run_daily_digests(self, pending_results: List[Dict], notifier) -> None:
        """
        Bundle results since midnight and send one digest per DAILY rule.
        Never raises.
        """
        try:
            rules = self.get_daily_digest_rules()
            if not rules or not pending_results:
                return

            for rule in rules:
                matches = [r for r in pending_results if self._matches_condition(rule.condition, r)]
                if not matches:
                    continue

                if notifier:
                    try:
                        from gateway.formatter import format_hope_alert
                        # Bundle: pass the first match as representative
                        payload = format_hope_alert(rule, matches[0], "LOW")
                        channel = self._resolve_channel("LOW")
                        notifier.send(channel=channel, payload=payload)
                    except Exception as ne:
                        logger.debug(f"HOPE: Digest send failed (non-fatal): {ne}")

                rule.trigger_count += len(matches)
                rule.last_triggered = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")

            # Persist counts
            all_rules = self.list_rules()
            rule_map = {r.rule_id: r for r in rules}
            for r in all_rules:
                if r.rule_id in rule_map:
                    r.trigger_count = rule_map[r.rule_id].trigger_count
                    r.last_triggered = rule_map[r.rule_id].last_triggered
            self._rewrite_hope_md(all_rules)

        except Exception as e:
            logger.warning(f"HOPE.run_daily_digests() failed (non-fatal): {e}")

    # ── Internal helpers ──────────────────────────────────────────────────────

    def _matches_condition(self, condition: str, result: Dict) -> bool:
        """
        Demo mode: keyword match — any word from condition found in str(result).
        Production mode: would call LLM for semantic match.
        """
        try:
            result_text = str(result).lower()
            # Split condition into keywords (ignore short words)
            keywords = [
                w.lower().strip(".,!?") for w in condition.split()
                if len(w) > 3
            ]
            return any(kw in result_text for kw in keywords)
        except Exception:
            return False

    def _rewrite_hope_md(self, rules: List[HopeRule]) -> None:
        """Fully rewrite HOPE.md from the rule list."""
        active_count = sum(1 for r in rules if r.status == "ACTIVE")
        total_fired = sum(r.trigger_count for r in rules)
        ts = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")

        lines = [
            f"# {self._slug} — HOPE Rules",
            f"_Last updated: {ts} | Active rules: {active_count} | Total fired: {total_fired}_",
            "",
        ]

        for rule in rules:
            lines += [
                "---",
                "",
                f"## {rule.rule_id} [{rule.status}]",
                f"**Condition**: {rule.condition}",
                f"**Schedule**: {rule.schedule}",
                f"**Action**: {rule.action}",
                f"**Priority**: {rule.priority}",
                f"**Created**: {rule.created_at}",
                f"**Trigger count**: {rule.trigger_count}",
                f"**Last triggered**: {rule.last_triggered}",
                "",
            ]

        lines.append("---")
        self._hope_file.write_text("\n".join(lines), encoding="utf-8")

    def _parse_rules(self, content: str) -> List[HopeRule]:
        """Parse HOPE.md sections into HopeRule objects."""
        rules: List[HopeRule] = []
        # Split on ## hope_NNN [STATUS] sections
        sections = re.split(r"\n## (hope_\d+) \[(\w+)\]", content)
        # sections[0] = header; then triplets: (rule_id, status, body)
        i = 1
        while i + 2 < len(sections):
            rule_id = sections[i].strip()
            status = sections[i + 1].strip()
            body = sections[i + 2]

            def _field(name: str, default: str = "") -> str:
                m = re.search(rf"\*\*{name}\*\*:\s*(.+)", body)
                return m.group(1).strip() if m else default

            try:
                tc_raw = _field("Trigger count", "0")
                tc = int(tc_raw) if tc_raw.isdigit() else 0
            except Exception:
                tc = 0

            rules.append(HopeRule(
                rule_id=rule_id,
                agent_slug=self._slug,
                condition=_field("Condition"),
                schedule=_field("Schedule", "IMMEDIATE"),
                action=_field("Action"),
                priority=_field("Priority", "NORMAL"),
                status=status,
                created_at=_field("Created"),
                trigger_count=tc,
                last_triggered=_field("Last triggered", "Never"),
            ))
            i += 3
        return rules

    def _is_muted(self, priority: str) -> bool:
        """
        Return True if current local hour is inside mute window.
        CRITICAL priority always bypasses mute.
        """
        if priority == "CRITICAL":
            return False
        try:
            now_hour = datetime.now().hour  # local time
            start = self._settings.HOPE_MUTE_START_HOUR
            end = self._settings.HOPE_MUTE_END_HOUR
            if start > end:  # crosses midnight (e.g. 23–07)
                return now_hour >= start or now_hour < end
            return start <= now_hour < end
        except Exception:
            return False

    def _rate_limited(self) -> bool:
        """
        Return True if non-CRITICAL alert count in the last 60 min
        has reached HOPE_MAX_ALERTS_PER_HOUR.
        """
        try:
            now = datetime.now(timezone.utc)
            # Evict entries older than 60 minutes
            while self._alert_window and (now - self._alert_window[0]).seconds > 3600:
                self._alert_window.popleft()
            return len(self._alert_window) >= self._settings.HOPE_MAX_ALERTS_PER_HOUR
        except Exception:
            return False

    def _resolve_channel(self, priority: str) -> str:
        """Resolve Slack channel from UserProfile based on priority."""
        try:
            from memory.user_profile import UserProfile
            profile = UserProfile(settings=self._settings)
            profile.load()
            return profile.get_channel_for_priority(priority)
        except Exception:
            channel_map = {
                "CRITICAL": "#breaking-alerts",
                "HIGH": "dm",
                "NORMAL": "#media-alerts",
                "LOW": "#media-alerts",
            }
            return channel_map.get(priority, "#mediaagentiq")
